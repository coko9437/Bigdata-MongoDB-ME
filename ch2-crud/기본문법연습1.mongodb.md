- **Part 1: `find`를 이용한 다채로운 데이터 조회 (1번 ~ 20번 예제)**
- **Part 2: 커서(Cursor)의 개념과 활용**
- **Part 3: 핵심 데이터 관리 (CRUD) 및 특별한 컬렉션**

---

### **ch2 코드 종합 설명**

이 코드는 MongoDB의 핵심 기능인 **데이터 조회(Read)**와 **생성(Create), 수정(Update), 삭제(Delete)**를 집중적으로 다룹니다. 특히 `find` 명령어와 함께 사용하는 다양한 '쿼리 연산자'들을 통해 원하는 데이터를 얼마나 유연하게 찾아낼 수 있는지 배울 수 있습니다.

---

### **Part 1: `find`를 이용한 다채로운 데이터 조회**

미리 준비된 `users` 컬렉션의 데이터를 대상으로, 다양한 조건과 연산자를 활용하여 문서를 검색하는 방법을 익힙니다.

#### **1. 코드, 문법 및 개별 설명**

**[데이터 준비]**

```javascript
// 더미 데이터 만들기
db.users.insertMany([
  /* ... 7명의 사용자 데이터 ... */
]);
```

: `users` 컬렉션에 7명의 다양한 정보를 가진 사용자 데이터를 한 번에 삽입합니다. 이 데이터는 아래의 모든 조회 예제에서 사용됩니다.

**[쿼리 예제 모음]**

```javascript
// ✅ 1. 나이가 25 이상인 사용자 찾기
db.users.find({ age: { $gte: 25 } });
```

: `users` 컬렉션에서 `age` 필드의 값이 25보다 크거나 같은(`$gte`) 모든 사용자를 찾습니다.

```javascript
// ✅ 2. 이름이 "Kim"인 사용자 찾기
db.users.find({ name: "Kim" });
```

: `name` 필드의 값이 정확히 "Kim"과 일치하는 사용자를 찾습니다.

```javascript
// ✅ 3. 나이가 30 또는 40인 사용자 찾기
db.users.find(
  { age: { $in: [30, 40] } }, // 조건
  { _id: 0, name: 1, email: 1, age: 1 } // 프로젝션
);
```

: `age`가 `[30, 40]` 배열에 포함된(`$in`) 사용자를 찾되, 결과 화면에는 `_id`를 제외하고(`_id: 0`) 이름, 이메일, 나이만(`필드: 1`) 보여줍니다.

```javascript
// ✅ 4. 나이가 30 이상이고, 도시가 "Seoul"인 사용자 찾기
db.users.find({ age: { $gte: 30 }, city: "Seoul" });
```

: 나이가 30 이상 **그리고(AND)** `city`가 "Seoul"인 두 조건을 모두 만족하는 사용자를 찾습니다.

```javascript
// ✅ 5. 이름이 "John"으로 시작하는 사용자 찾기
db.users.find({ name: { $regex: "^John" } });
```

: 정규 표현식(`$regex`)을 이용해 `name` 필드가 "John"으로 시작(`^`)하는 사용자를 찾습니다.

```javascript
// ✅ 6. 나이가 20~40 사이인 사용자 찾기
db.users.find({ age: { $gte: 20, $lte: 40 } });
```

: `age`가 20 이상(`$gte`)이고 40 이하(`$lte`)인, 즉 두 값 사이의 범위에 속하는 사용자를 찾습니다.

```javascript
// ✅ 7. 태그에 "sports"가 포함된 사용자 찾기
db.users.find({ tags: "sports" });
```

: `tags` 배열 필드 안에 "sports"라는 문자열 요소가 포함된 모든 사용자를 찾습니다.

```javascript
// ✅ 8. 배열 크기가 3인 사용자 찾기
db.users.find({ tags: { $size: 3 } });
```

: `tags` 배열의 요소 개수(길이)가 정확히 3개인(`$size`) 사용자를 찾습니다.

```javascript
// ✅ 9. reviews 배열에서 마지막 2개만 가져오기
db.users.find({}, { reviews: { $slice: -2 } });
```

: 모든 문서(`{}`)를 대상으로 하되, 프로젝션을 이용해 `reviews` 배열의 끝에서부터 2개 요소만 잘라서(`$slice`) 결과에 포함시킵니다.

```javascript
// ✅ 10. 성별이 "남성"이고 나이가 30 이상인 사용자 찾기
db.users.find({ gender: "남성", age: { $gte: 30 } });
```

: `gender`가 "남성" **그리고(AND)** `age`가 30 이상인 사용자를 찾습니다.

```javascript
// ✅ 11. location 필드가 없는 사용자 찾기
db.users.find({ location: { $exists: false } });
```

: 문서 내에 `location`이라는 필드 자체가 존재하지 않는(`$exists: false`) 모든 사용자를 찾습니다.

```javascript
// ✅ 12. 이름이 "Lee"가 아닌 사용자 찾기
db.users.find({ name: { $ne: "Lee" } });
```

: `name` 필드의 값이 "Lee"가 아닌(`$ne`: Not Equal) 모든 사용자를 찾습니다.

```javascript
// ✅ 13. orders 배열의 첫 번째 요소만 가져오기
db.users.find({}, { orders: { $slice: 1 } });
```

: 모든 문서를 대상으로, 프로젝션을 이용해 `orders` 배열의 앞에서부터 1개 요소만 잘라서(`$slice`) 결과에 포함시킵니다.

```javascript
// ✅ 14. 태그에 "music" 또는 "travel"이 포함된 사용자 찾기
db.users.find({ tags: { $in: ["music", "travel"] } });
```

: `tags` 배열에 "music" 이나 "travel" 중 하나 이상의 요소를 포함(`$in`)하는 모든 사용자를 찾습니다.

```javascript
// ✅ 15. 이메일이 특정 도메인("@gmail.com")을 포함하는 사용자 찾기
db.users.find({ email: { $regex: "@gmail\\.com$" } });
```

: 정규 표현식(`$regex`)을 이용해 `email` 필드가 "@gmail.com"으로 끝나는(`$`) 사용자를 찾습니다. (`.`은 정규식 특수문자이므로 `\\`로 이스케이프 처리합니다)

```javascript
// ✅ 16. 특정 텍스트를 포함하는 사용자 찾기
db.users.createIndex({ name: "text", email: "text" });
db.users.find({ $text: { $search: "kim" } });
```

: 먼저 `name`과 `email` 필드에 대해 텍스트 검색을 위한 인덱스를 생성합니다. 그 후, `$text` 검색을 통해 해당 필드들에서 "kim"이라는 단어를 포함하는 사용자를 찾습니다.

````javascript
// ✅ 17. score 값이 80 이상인 사용자 찾기
db.users.find({ score: { $gte: 80 } });```
: `score` 필드의 값이 80보다 크거나 같은(`$gte`) 사용자를 찾습니다.

```javascript
// ✅ 18. status 값이 "active"인 사용자 찾기
db.users.find({ status: "active" });
````

: `status` 필드의 값이 "active"와 일치하는 사용자를 찾습니다.

```javascript
// ✅ 19. points 필드가 존재하는 사용자 찾기
db.users.find({ points: { $exists: true } });
```

: 문서 내에 `points` 라는 필드가 존재하는(`$exists: true`) 모든 사용자를 찾습니다.

```javascript
// ✅ 20. orders 배열의 크기가 5인 사용자 찾기
db.users.find({ orders: { $size: 5 } });
```

: `orders` 배열의 요소 개수가 정확히 5개인(`$size`) 사용자를 찾습니다. (5개 '이상'이 아님에 주의!)

#### **2. 해당 설명**

위 예제들은 MongoDB 조회 기능의 핵심인 **'쿼리 객체'**와 **'연산자'**의 활용법을 보여줍니다. `{ "필드명": "값" }` 형태의 단순한 일치 검색부터, `$gte`, `$in`, `$regex` 등 `$`로 시작하는 다양한 연산자를 조합하여 숫자 범위, 문자열 패턴, 배열 포함 여부 등 매우 구체적이고 복잡한 조건으로 데이터를 찾아낼 수 있습니다. 또한, 두 번째 인자로 전달하는 **'프로젝션'**을 통해 결과로 보고 싶은 필드만 선택적으로 가져올 수 있어 효율적인 데이터 조회가 가능합니다.

#### **3. 응용 가능한 예제**

**"서울(Seoul)에 살지 않으면서 'fashion' 태그를 가지고 있고, 점수(score)가 90점 이상인 사용자의 이름과 도시, 점수만 찾아보기"**

```javascript
db.users.find(
  // 조건
  {
    city: { $ne: "Seoul" },
    tags: "fashion",
    score: { $gte: 90 },
  },
  // 프로젝션
  {
    _id: 0,
    name: 1,
    city: 1,
    score: 1,
  }
);
```

#### **4. 심화 내용 (논리 연산자 `$or`, `$not`)**

여러 조건 중 하나만 만족해도 되는 **`OR`** 조건이나, 특정 조건을 만족하지 **않는(`NOT`)** 문서를 찾을 때는 명시적인 논리 연산자를 사용해야 합니다.

**"도시가 'Busan'이거나 또는(OR) 'tags'에 'gaming'이 포함된 사용자 찾기"**

```javascript
db.users.find({
  $or: [{ city: "Busan" }, { tags: "gaming" }],
});
```

**"나이가 30살 미만이 아닌(`NOT` `lt`) 사용자 찾기 (즉, 30세 이상)"**

```javascript
db.users.find({ age: { $not: { $lt: 30 } } });
```

#### **5. 추가하고 싶은 내용**

16번 예제의 `텍스트 인덱스`는 매우 강력한 기능입니다. 일반 인덱스는 필드 값 전체가 일치하는지를 빠르게 찾는 데 목적이 있지만, 텍스트 인덱스는 필드 내용의 단어들을 기반으로 인덱스를 만들어 주기 때문에, 마치 구글 검색처럼 문장 안의 특정 단어로 검색이 가능합니다. 블로그 본문 검색, 상품 설명 검색 등에 매우 유용합니다.

---

### **Part 2: 커서(Cursor)의 개념과 활용**

`find`가 반환한 대량의 결과 데이터를 효율적으로 다루는 방법을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 커서 예시 1: .forEach()
db.users.find({ score: { $gte: 80 } }).forEach(function (user) {
  print("Name: " + user.name + ", Score: " + user.score);
});
```

: 점수가 80점 이상인 모든 사용자를 찾아, 그 결과를 하나씩 순회하며 콜백 함수(function)를 실행시켜 이름과 점수를 출력합니다.

````javascript
// 커서 예시 2: .hasNext() + .next()
const activeUsersCursor = db.users.find({ status: "active" });
while (activeUsersCursor.hasNext() && count < 2) {
  const user = activeUsersCursor.next();
  printjson(user);
}
```: `status`가 "active"인 사용자 검색 결과를 `activeUsersCursor` 변수에 담아두고, `while` 루프를 통해 다음 문서가 있는지(`hasNext`) 확인하고 가져와서(`next`) 출력하는 과정을 처음 2명에게만 반복합니다.

#### **2. 해당 설명**
`db.users.find()`를 실행하면 수백만 개의 결과가 한 번에 메모리로 로드되는 것이 아니라, 결과 목록을 가리키는 '포인터'와 같은 **'커서(Cursor)'** 객체가 반환됩니다. 이 커서를 통해 우리는 대용량의 데이터를 필요한 만큼씩 나누어 처리할 수 있어 시스템 자원을 효율적으로 사용할 수 있습니다. `.forEach()`는 커서의 모든 데이터를 순회하는 간편한 방법이며, `.hasNext()`와 `.next()`는 커서를 수동으로 제어하여 더 복잡한 로직을 구현할 수 있게 해줍니다.

#### **3. 응용 가능한 예제**
**"모든 사용자를 조회하면서, 각 사용자의 `orders` 개수를 세고, 주문이 5건 이상이면 'VIP', 3건 이상이면 '우수', 그 외에는 '일반' 등급을 부여하여 이름과 함께 출력하기"**
```javascript
db.users.find().forEach(user => {
  const orderCount = user.orders ? user.orders.length : 0;
  let grade = "일반";

  if (orderCount >= 5) {
    grade = "VIP";
  } else if (orderCount >= 3) {
    grade = "우수";
  }

  print(`사용자: ${user.name}, 등급: ${grade}`);
});
````

#### **4. 심화 내용 (커서 제어 메서드)**

커서는 데이터를 순회하기 전에 정렬하거나 일부를 건너뛰는 등 다양한 제어 기능을 제공합니다. 이들은 메서드 체인(method chain) 형태로 `find`에 이어서 사용됩니다.

- **`.sort({ 필드: -1 })`**: 결과를 내림차순(-1) 또는 오름차순(1)으로 정렬합니다.
- **`.limit(숫자)`**: 결과의 개수를 제한합니다.
- **`.skip(숫자)`**: 지정된 개수만큼 결과를 건너뛰고 그 다음부터 반환합니다.

**"나이가 많은 순으로 정렬하되, 1등은 건너뛰고 2등과 3등만 조회하기 (페이지네이션 구현의 핵심)"**

```javascript
db.users
  .find()
  .sort({ age: -1 }) // 나이 기준 내림차순 정렬
  .skip(1) // 첫 번째 결과 건너뛰기
  .limit(2); // 2개의 결과만 가져오기
```

#### **5. 추가하고 싶은 내용**

VSCode Playground에서 `find()`를 실행하면 기본적으로 처음 20개의 문서만 결과 창에 표시됩니다. 이것 역시 모든 결과를 한 번에 보여주지 않고 커서를 통해 일부만 가져오는 동작 방식 때문입니다. 모든 결과를 배열 형태로 보고 싶다면 코드 끝에 `.toArray()`를 붙여 실행하면 됩니다.

---

### **Part 3: 핵심 데이터 관리 (CRUD) 및 특별한 컬렉션**

데이터를 생성, 수정, 삭제하는 기본적인 작업과 특수한 목적을 가진 Capped Collection을 알아봅니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// [Create] 하나 입력
db.users.insertOne({ name: "홍길동", age: 20 /* ... */ });
```

: `users` 컬렉션에 '홍길동'이라는 새로운 사용자 문서 하나를 삽입합니다.

```javascript
// [Read] 조회
db.users.find();
```

: `users` 컬렉션의 모든 문서를 조회합니다.

```javascript
// [Update] 수정
db.users.updateOne({ name: "홍길동" }, { $set: { age: 30 } });
```

: `name`이 "홍길동"인 첫 번째 문서를 찾아, `$set` 연산자를 사용해 `age` 필드의 값만 30으로 수정합니다.

```javascript
// [Delete] 삭제
db.users.deleteOne({ name: "홍길동" });
```

: `name`이 "홍길동"인 첫 번째 문서를 찾아 삭제합니다.

```javascript
// Capped Collection 생성 및 데이터 삽입
db.createCollection("logs3", { capped: true, size: 5000 });
for (let i = 0; i < 1000; i++) {
  /* ... */
}
```

: 최대 크기가 5000바이트로 고정된(`capped: true`) `logs3` 컬렉션을 생성합니다. 이 컬렉션은 데이터가 꽉 차면 가장 오래된 데이터부터 자동으로 삭제되는 특징을 가집니다.

#### **2. 해당 설명**

이 부분은 모든 데이터베이스의 기본인 **CRUD(Create, Read, Update, Delete)** 작업을 보여줍니다. MongoDB에서는 `insertOne` (생성), `find` (읽기), `updateOne` (수정), `deleteOne` (삭제)과 같은 직관적인 명령어를 사용합니다. 특히 데이터를 수정할 때 **`$set` 연산자**를 사용하는 것이 매우 중요합니다. `$set` 없이 수정하면 지정한 필드만 바뀌는 것이 아니라 문서 전체가 교체되기 때문입니다. **Capped Collection**은 크기가 고정되어 오래된 데이터가 자동으로 삭제되므로, 최신 로그나 실시간 데이터 스트림을 저장하는 용도로 매우 유용합니다.

#### **3. 응용 가능한 예제 (퀴즈 풀이 및 개선)**

코드에 포함된 퀴즈는 CRUD 문법을 연습하기에 좋습니다. 특히 퀴즈 2번을 배열에 요소를 '추가'하는 방식으로 개선해 보겠습니다.

**"퀴즈 2 개선: '이상용'의 `favorite` 배열에 '김치찌개'를 추가하고, `birth` 필드 업데이트하기"**

```javascript
db.users2.updateOne(
  { name: "이상용" }, // 조건
  {
    $push: { favorite: "김치찌개" }, // $push: 배열에 요소 추가
    $set: { birth: "1984-12-07" }, // $set: 필드 값 수정
  }
);
```

#### **4. 심화 내용 (다수 문서 처리 및 Upsert)**

- **다수 문서 처리**: `insertOne`, `updateOne`, `deleteOne` 대신 `insertMany`, `updateMany`, `deleteMany`를 사용하면 조건에 맞는 여러 문서를 한 번에 처리할 수 있습니다.
- **Upsert 옵션**: Update와 Insert를 합친 개념입니다. `{ upsert: true }` 옵션을 주면, 조건에 맞는 문서가 **있으면 수정**하고 **없으면 새로운 문서를 삽입**합니다.

**"모든 'inactive' 사용자의 상태를 'archived'로 한 번에 변경하기"**

```javascript
db.users.updateMany({ status: "inactive" }, { $set: { status: "archived" } });
```

**"사용자 'Choi'의 점수를 10점 올리되, 만약 'Choi'가 없으면 score가 10인 사용자로 새로 추가하기"**

````javascript
db.users.updateOne(
  { name: "Choi" },
  { $inc: { score: 10 } }, // $inc: 지정한 값만큼 필드 값을 증가/감소
  { upsert: true }
);```

#### **5. 추가하고 싶은 내용**
`db.serverStatus()`는 현재 실행 중인 MongoDB 서버의 다양한 상태 정보(연결 수, 메모리 사용량, 네트워크 트래픽 등)를 아주 상세하게 보여주는 관리자용 명령어입니다. 데이터베이스의 성능을 모니터링하거나 문제를 진단할 때 유용하게 사용할 수 있습니다.
````
