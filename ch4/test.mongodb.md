### **ch4 코드 종합 설명**

이 코드는 MongoDB의 핵심 철학인 **데이터 모델링과 설계**에 대한 개념을 다룹니다. 관계형 데이터베이스(RDBMS)와 달리 정해진 형식이 없는 MongoDB에서, 어떤 기준으로 데이터를 구성해야(스키마 설계) 성능과 확장성을 모두 잡을 수 있는지에 대한 다양한 전략과 패턴을 배웁니다. 마지막으로, 스키마의 유연함 속에서 데이터의 일관성을 지키는 방법인 **Validator**의 실제 사용법을 익힙니다.

---

### **Part 1: RDBMS vs. MongoDB - 패러다임의 전환**

데이터를 바라보는 근본적인 시각 차이와 MongoDB 설계의 기본 특징을 이해합니다.

#### **1. 코드, 문법 및 개념 표현**

```javascript
// 관계형 데이터베이스 (RDBMS) - 정규화된 데이터
// 1. users 테이블
// +----+-------+----------+
// | id | name  | email    |
// +----+-------+----------+
// | 1  | Alice | a@a.com  |
// +----+-------+----------+
// 2. address 테이블
// +----+---------+-------+---------+
// | id | user_id | city  | zip     |
// +----+---------+-------+---------+
// | 1  | 1       | Seoul | 12345   |
// +----+---------+-------+---------+

// MongoDB - 비정규화된 문서 (Embedded)
// 1. users 컬렉션
// {
//   "_id": ObjectId("..."),
//   "name": "Alice",
//   "email": "a@a.com",
//   "address": { "city": "Seoul", "zip": "12345" }
// }
```

: RDBMS는 데이터를 역할에 따라 여러 테이블로 '분리'하여 저장하지만, MongoDB는 관련된 데이터를 하나의 '문서(Document)' 안에 함께 '포함'하여 저장할 수 있습니다.

#### **2. DB의 데이터 저장 및 접근 방식**

##### **RDBMS의 데이터 접근 순서 (JOIN)**

1.  **[사용자]** 'Alice'의 주소를 찾기 위해 쿼리 요청.
2.  **[DB]** `users` 테이블에서 `name`이 'Alice'인 행을 찾습니다. (디스크 I/O #1)
3.  **[DB]** 찾은 행에서 `id` 값인 `1`을 얻습니다.
4.  **[DB]** `address` 테이블로 이동하여 `user_id`가 `1`인 행을 찾습니다. (디스크 I/O #2)
5.  **[DB]** 두 테이블에서 찾은 데이터를 메모리상에서 조합(**JOIN**)하여 최종 결과를 만듭니다.
6.  **[결과]** 여러 번의 탐색과 조합 과정이 필요합니다.

##### **MongoDB의 데이터 접근 순서 (Embedded Document)**

1.  **[사용자]** 'Alice'의 주소를 찾기 위해 쿼리 요청.
2.  **[DB]** `users` 컬렉션에서 `name`이 'Alice'인 문서를 찾습니다. (디스크 I/O #1)
3.  **[DB]** 찾은 문서 안에 `address` 정보가 이미 포함되어 있습니다.
4.  **[결과]** 단 한 번의 탐색으로 모든 관련 데이터를 가져옵니다. **JOIN이 필요 없습니다.**

#### **3. 해당 설명**

MongoDB 데이터 모델링의 핵심은 **"Application에서 함께 사용하는 데이터는, 물리적으로도 함께 저장하는 것을 우선적으로 고려한다"**는 것입니다. RDBMS가 데이터 중복을 피하기 위해 '정규화(Normalization)'를 최우선으로 하는 반면, MongoDB는 **읽기 성능(Read Performance)**을 극대화하기 위해 '비정규화(Denormalization)'를 적극적으로 활용합니다. 이로 인해 `JOIN` 연산이 사라져 쿼리가 단순해지고 응답 속도가 빨라지는 큰 장점을 얻습니다.

#### **4. 응용 가능한 예제**

**"블로그 게시물과 그에 달린 댓글들을 저장하는 경우"**

- **RDBMS**: `posts` 테이블과 `comments` 테이블을 만들고, `post_id`로 연결합니다. 댓글을 보려면 항상 두 테이블을 `JOIN`해야 합니다.
- **MongoDB**: `posts` 컬렉션의 문서 안에 `comments`를 배열 형태로 함께 저장합니다. 특정 게시물을 불러오는 단 한 번의 쿼리로 모든 댓글 정보까지 가져올 수 있습니다.

#### **5. 심화 내용 (데이터의 원자성 - Atomicity)**

MongoDB에서 단일 문서 내의 업데이트는 '원자적(Atomic)'으로 처리됩니다. 즉, 작업이 전부 성공하거나 전부 실패하는 것이 보장됩니다. 위 블로그 예제에서 게시물 제목을 수정하고 댓글을 하나 추가하는 작업을 하나의 문서에 대한 단일 업데이트로 처리할 수 있습니다. RDBMS에서는 `posts` 테이블 업데이트와 `comments` 테이블 삽입이라는 두 개의 작업을 트랜잭션으로 묶어야만 원자성을 보장할 수 있습니다.

#### **6. 추가하고 싶은 내용**

'스키마가 유연하다'는 것이 '스키마가 없다'는 뜻은 아닙니다. 규칙이 없을 뿐, 설계가 없다는 의미가 아닙니다. 오히려 개발자가 애플리케이션의 데이터 패턴을 명확히 이해하고 그에 맞는 최적의 구조를 직접 설계해야 하는 책임이 따릅니다.

---

### **Part 2: 설계의 핵심 기준 - 정규화 vs. 비정규화**

어떤 경우에 데이터를 분리(참조)하고, 어떤 경우에 데이터를 포함(임베드)해야 하는지에 대한 설계 기준을 배웁니다.

#### **1. 코드, 문법 및 개념 표현**

```javascript
// 1. 참조(Reference) 패턴 - 정규화
// users 컬렉션
// { "_id": "user1", "name": "Alice" }
// orders 컬렉션
// { "_id": "order1", "userId": "user1", "product": "Laptop" }
// { "_id": "order2", "userId": "user1", "product": "Mouse" }

// 2. 임베드(Embedded) 패턴 - 비정규화
// users 컬렉션
// {
//   "_id": "user1",
//   "name": "Alice",
//   "orders": [
//     { "orderId": "order1", "product": "Laptop" },
//     { "orderId": "order2", "product": "Mouse" }
//   ]
// }
```

: 사용자와 주문 정보를 **별도의 컬렉션**에 저장하고 `userId`로 연결하는 것이 참조(정규화) 방식이고, 사용자 문서 안에 `orders` 배열로 **함께 저장**하는 것이 임베드(비정규화) 방식입니다.

#### **2. DB의 데이터 저장 및 접근 방식**

##### **참조(Reference) 패턴의 데이터 접근**

1.  **[DB]** `users`와 `orders`라는 두 개의 컬렉션(파일)이 별도로 존재합니다.
2.  **[사용자]** 'Alice'의 모든 주문을 찾기 위해 쿼리.
3.  **[DB]** 먼저 `users` 컬렉션에서 "Alice"를 찾아 `_id`인 "user1"을 얻습니다. (1차 쿼리)
4.  **[DB]** 그 다음, `orders` 컬렉션에서 `userId`가 "user1"인 모든 문서를 검색합니다. (2차 쿼리)
5.  **[결과]** 애플리케이션 레벨에서 두 번의 쿼리가 필요하거나, DB 레벨에서 `$lookup` (MongoDB의 JOIN 연산) 파이프라인을 사용해야 합니다.

##### **임베드(Embedded) 패턴의 데이터 접근**

1.  **[DB]** `users` 컬렉션 내에 주문 정보가 포함된 채로 데이터가 저장됩니다.
2.  **[사용자]** 'Alice'의 모든 주문을 찾기 위해 쿼리.
3.  **[DB]** `users` 컬렉션에서 "Alice"를 찾습니다.
4.  **[DB]** 해당 문서의 `orders` 필드를 읽으면 모든 주문 정보가 이미 들어있습니다.
5.  **[결과]** 단 한 번의 쿼리로 모든 작업이 끝납니다.

#### **3. 해당 설명**

데이터 모델링의 핵심은 이 두 패턴 사이의 트레이드오프를 이해하는 것입니다.

- **임베드(비정규화)를 선택할 때**:
  - **장점**: 읽기 성능이 매우 빠름 (`JOIN` 불필요). 관련된 데이터를 한 번에 업데이트 가능(원자성).
  - **단점**: 데이터가 중복될 수 있음. 문서 크기가 계속 커질 수 있음 (MongoDB는 단일 문서 크기가 16MB로 제한됨).
  - **적합한 관계**: 'Contains' 관계 (부분-전체). 부모 없이는 자식이 의미 없는 경우 (게시물과 댓글, 상품과 리뷰).
- **참조(정규화)를 선택할 때**:
  - **장점**: 데이터 중복이 최소화되어 일관성 유지에 유리. 16MB 문서 크기 제한을 피할 수 있음.
  - **단점**: 관련된 데이터를 읽으려면 여러 번 쿼리하거나 `$lookup`을 사용해야 해서 읽기 성능이 상대적으로 느림.
  - **적합한 관계**: 'Uses' 또는 다대다 관계. 각 데이터가 독립적으로 의미가 있고 자주 변경되는 경우 (상품과 주문, 학생과 강의).

#### **4. 응용 가능한 예제**

**"출판사와 책의 관계 모델링"**

- 한 출판사가 출간하는 책의 수가 수십~수백 권 정도로 제한적이라면, 출판사 문서에 `books` 배열을 **임베드**하는 것이 책 목록을 한 번에 가져오기 편리합니다.
- 만약 아마존처럼 수백만 권의 책 데이터를 다루고, 책 정보가 독립적으로 매우 중요하다면, `publishers`와 `books` 컬렉션을 분리하고 `publisher_id`로 **참조**하는 것이 훨씬 합리적입니다.

#### **5. 심화 내용 (하이브리드 패턴)**

두 패턴의 장점을 결합한 하이브리드(Hybrid) 방식도 많이 사용됩니다. 예를 들어, 상품 문서 안에 **가장 최근 리뷰 5개는 임베드**하여 상품 페이지에서 빠르게 보여주고, 전체 리뷰 목록은 `reviews` 컬렉션에서 **참조**를 통해 가져오는 '더 보기' 기능으로 구현할 수 있습니다.

#### **6. 추가하고 싶은 내용**

설계의 정답은 없습니다. 내 서비스의 **데이터가 어떻게 사용될 것인지(쿼리 패턴)**를 예측하는 것이 가장 중요합니다. '사용자들이 상품 페이지에서 무엇을 가장 많이 볼까?', '어떤 데이터가 함께 변경될까?'를 기준으로 모델을 선택해야 합니다.

---

### **Part 3: 스키마 유효성 검사 (Schema Validation) - Validator**

유연한 스키마의 단점을 보완하고 데이터의 품질과 일관성을 보장하는 방법을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 'users' 컬렉션 생성 시 유효성 검사 규칙(validator)을 함께 정의
db.createCollection("users", {
  validator: {
    $jsonSchema: {
      bsonType: "object", // 문서의 타입은 객체여야 함
      required: ["name", "email"], // 'name'과 'email' 필드는 필수
      properties: {
        // 각 필드에 대한 규칙 정의
        name: { bsonType: "string", description: "필수 필드" },
        age: { bsonType: "int", minimum: 18, description: "18세 이상" },
        email: {
          bsonType: "string",
          pattern: "^.*@.*\\..*$", // 이메일 정규식 패턴과 일치해야 함
          description: "유효한 이메일",
        },
      },
    },
  },
});
```

: `users` 컬렉션을 생성할 때, 앞으로 이 컬렉션에 들어올 모든 문서는 반드시 이 규칙을 통과해야 한다는 '입국 심사대'를 설치하는 것과 같습니다.

```javascript
// 유효하지 않은 데이터 삽입 시도 (이메일 형식 오류)
db.users.insertOne({
  name: "Bob",
  email: "bobexample.com", // pattern 규칙 위반
  age: 30,
});
// ❌ MongoDB가 삽입을 거부하고 오류를 반환합니다.
```

: 유효성 검사 규칙에 맞지 않는 데이터를 삽입하려고 하면, MongoDB 데이터베이스 레벨에서 해당 작업을 차단하여 데이터 오염을 방지합니다.

#### **2. Validator의 생성 로직 및 DB의 데이터 처리 순서**

1.  **[사용자]** `db.createCollection("users", { validator: ... })` 명령 실행.
2.  **[DB]** `users`라는 이름의 새로운 컬렉션을 생성합니다.
3.  **[DB]** 주어진 `validator` 객체의 `$jsonSchema` 규칙을 이 컬렉션의 **메타데이터(설정 정보)**로 저장합니다. 이 시점에는 아직 아무 데이터도 없습니다.
4.  ***
5.  **[사용자]** `db.users.insertOne({ ... })` 명령으로 데이터 삽입 시도.
6.  **[DB]** **디스크에 데이터를 쓰기 직전에**, `users` 컬렉션의 메타데이터에 저장된 `validator` 규칙을 먼저 읽어옵니다.
7.  **[DB]** 삽입하려는 문서가 이 규칙(필수 필드 존재 여부, 타입, 패턴, 숫자 범위 등)에 모두 부합하는지 **검사**합니다.
8.  **[DB - 성공 시]** 모든 규칙을 통과하면, 문서를 디스크에 정상적으로 기록하고 성공을 반환합니다.
9.  **[DB - 실패 시]** 규칙 중 하나라도 위반하면, 디스크에 **기록하는 작업을 즉시 중단**하고, 어떤 규칙을 위반했는지에 대한 오류 메시지를 사용자에게 반환합니다.

#### **3. 해당 설명**

스키마 Validator는 MongoDB의 유연성으로 인해 발생할 수 있는 데이터 품질 저하 문제를 방지하는 강력한 기능입니다. 애플리케이션 코드에서 유효성 검사를 누락하더라도, 데이터베이스가 최후의 보루가 되어 데이터의 일관성과 무결성을 지켜줍니다. `$jsonSchema`를 사용하면 필드의 타입(`bsonType`), 필수 여부(`required`), 숫자 범위(`minimum`, `maximum`), 정규식 패턴(`pattern`) 등 매우 상세한 규칙을 정의할 수 있습니다.

#### **4. 응용 가능한 예제**

**"상품(products) 컬렉션에 대한 Validator 정의하기"**

```javascript
db.createCollection("products", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["productName", "price", "stock", "status"],
      properties: {
        productName: { bsonType: "string" },
        price: { bsonType: "double", minimum: 0 }, // 가격은 0 이상
        stock: { bsonType: "int", minimum: 0 }, // 재고는 0 이상
        tags: { bsonType: "array", items: { bsonType: "string" } }, // 태그는 문자열 배열
        status: { enum: ["On Sale", "Sold Out", "Coming Soon"] }, // status는 셋 중 하나의 값만 허용
      },
    },
  },
});
```

#### **5. 심화 내용 (`validationLevel` & `validationAction`)**

기존에 데이터가 많은 컬렉션에 Validator를 추가할 때 유용한 옵션들입니다.

- `validationLevel`:
  - `strict` (기본값): 모든 삽입 및 수정에 규칙을 적용합니다.
  - `moderate`: 삽입과, **규칙을 통과하는 기존 문서의 수정**에만 규칙을 적용합니다. (이미 잘못된 데이터는 건드리지 않음)
- `validationAction`:
  - `error` (기본값): 규칙 위반 시 작업을 거부하고 오류를 발생시킵니다.
  - `warn`: 규칙 위반 시 작업을 허용하되, MongoDB 로그에 경고 메시지를 남깁니다. (점진적으로 스키마를 적용할 때 유용)

#### **6. 추가하고 싶은 내용**

Validator는 컬렉션 생성 시뿐만 아니라, `collMod`(컬렉션 수정) 명령어를 사용해 이미 존재하는 컬렉션에 추가하거나 수정할 수도 있습니다. 이를 통해 서비스 운영 중에 점진적으로 데이터 품질 관리 정책을 강화해 나갈 수 있습니다.

```javascript
// 기존 users 컬렉션에 validator 추가 또는 변경
db.runCommand({
  collMod: "users",
  validator: {
    /* ... 새로운 규칙 ... */
  },
});
```
