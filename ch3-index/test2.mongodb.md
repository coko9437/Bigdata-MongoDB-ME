`explain`을 통해 인덱스가 실제로 어떻게 동작하는지 눈으로 확인하고, 복합 인덱스의 동작 원리를 더 깊게 파고드는, 매우 실용적이고 중요한 부분입니다.

---

### **ch3 (Part 2) 코드 종합 설명**

이 코드는 인덱스가 쿼리 성능에 미치는 영향을 **직접 확인(`explain`)**하고, **복합 인덱스**의 핵심 원리인 **'필드 순서'**의 중요성을 이해하는 데 초점을 맞춥니다. 또한, 인덱스를 활용한 정렬(`sort`), `OR` 쿼리, 그리고 최고의 성능을 내는 커버드 쿼리(Covered Query)와 인덱스를 강제로 지정하는 `hint`까지 다루는 심화 학습 과정입니다.

---

### **Part 1: `explain()` - 쿼리 실행 계획 분석**

내 쿼리가 인덱스를 잘 사용하고 있는지, MongoDB가 어떤 방식으로 일을 처리하는지 확인하는 '성능 분석 도구'를 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// posts 컬렉션에 샘플 데이터 삽입
db.posts.insertMany([
  {
    title: "Post A",
    author: "User A",
    category: "Tech",
    createdAt: new Date("2024-01-01"),
  },
  {
    title: "Post B",
    author: "User B",
    category: "Health",
    createdAt: new Date("2024-01-02"),
  },
  {
    title: "Post C",
    author: "User A",
    category: "Life",
    createdAt: new Date("2024-01-03"),
  },
]);

// 쿼리에 대한 실행 계획 확인
db.posts.find({ author: "User A" }).explain("executionStats");
```

: `author`가 "User A"인 게시물을 찾는 쿼리가 **어떻게 실행될 것인지(또는 실행되었는지)에 대한 상세한 분석 리포트**를 출력합니다. 데이터를 찾는 것이 아니라, 찾는 '방법'을 보여줍니다.

#### **2. 인덱스 생성 로직 및 DB의 데이터 접근 순서**

##### **인덱스 생성 전**

1.  **[사용자]** `db.posts.find({ author: "User A" })` 쿼리 실행.
2.  **[MongoDB]** `author` 필드에 사용할 인덱스가 있는지 확인 → **없음**.
3.  **[MongoDB]** 어쩔 수 없이 `posts` 컬렉션의 **첫 번째 문서부터 마지막 문서까지** 하나씩 차례대로 방문 (책의 첫 페이지부터 끝 페이지까지 넘기는 것과 같음).
4.  **[MongoDB]** 각 문서를 열어 `author` 필드 값이 "User A"와 일치하는지 비교.
5.  **[MongoDB]** 일치하는 문서를 찾으면 결과 목록에 추가. 이 과정을 모든 문서에 대해 반복.
6.  **[결과]** 이 방식을 **`COLLSCAN` (Collection Scan)** 이라고 하며, `explain` 결과의 `stage`에 표시됩니다. 데이터가 많을수록 극도로 비효율적입니다.

##### **인덱스 생성 후**

1.  **[사용자]** `db.posts.createIndex({ author: 1 })` 인덱스 생성.
2.  **[MongoDB]** `posts` 컬렉션의 모든 문서를 훑으며 `author` 필드 값과 해당 문서의 디스크 위치(주소)를 수집.
3.  **[MongoDB]** 수집된 `[author 값, 문서 주소]` 쌍을 `author` 필드 기준으로 정렬 (예: 알파벳순)하여 B-Tree라는 효율적인 자료 구조로 만들어 별도 공간에 저장. 이것이 바로 인덱스입니다.
4.  ***
5.  **[사용자]** 다시 `db.posts.find({ author: "User A" })` 쿼리 실행.
6.  **[MongoDB]** `author` 필드에 사용할 인덱스가 있는지 확인 → **있음**.
7.  **[MongoDB]** 컬렉션이 아닌 **`author` 인덱스**로 바로 접근.
8.  **[MongoDB]** 정렬된 인덱스 구조 내에서 "User A" 값을 매우 빠르게 탐색(O(log n)).
9.  **[MongoDB]** "User A"에 해당하는 문서 주소들을 인덱스에서 찾아낸 뒤, 그 주소를 이용해 디스크의 실제 문서 위치로 **직접 점프하여** 데이터를 가져옴.
10. **[결과]** 이 방식을 **`IXSCAN` (Index Scan)** 이라고 하며, `explain` 결과에 표시됩니다. `COLLSCAN`에 비해 압도적으로 빠릅니다.

#### **3. 해당 설명**

`explain()`은 개발자에게 MongoDB의 내부 동작을 보여주는 투시경과 같습니다. 이 명령의 결과에서 가장 중요하게 봐야 할 것은 다음과 같습니다.

- `executionStats.winningPlan.stage`: 쿼리의 실행 단계. `COLLSCAN`이라면 인덱스를 못 쓴 것이고, `IXSCAN`이라면 인덱스를 잘 쓴 것입니다.
- `executionStats.totalDocsExamined`: 쿼리를 위해 총 몇 개의 문서를 확인했는가. `COLLSCAN`일 경우 전체 문서 수와 비슷하고, `IXSCAN`일 경우 결과 문서 수와 비슷하게 나옵니다.
- `executionStats.executionTimeMillis`: 쿼리 실행에 걸린 시간(밀리초).

#### **4. 응용 가능한 예제**

**"서비스의 특정 페이지가 갑자기 느려졌을 때, 해당 페이지에서 사용하는 쿼리를 찾아 `explain()`을 실행하여 인덱스가 제대로 사용되고 있는지, 불필요한 풀 스캔(`COLLSCAN`)이 발생하고 있는지 진단할 수 있습니다."**

#### **5. 심화 내용**

`explain()`은 여러 모드를 가집니다.

- `explain("queryPlanner")`: 쿼리를 실제로 실행하지 않고, 어떤 실행 계획들을 후보로 고려했고 최종적으로 어떤 계획(`winningPlan`)을 선택했는지만 보여줍니다. 가장 간단하게 확인할 때 사용합니다.
- `explain("executionStats")`: 쿼리를 실제로 실행하고, 선택된 계획이 실행되면서 소요된 시간, 확인한 문서 수 등 상세한 통계 정보를 함께 보여줍니다. 성능 튜닝 시 가장 많이 사용합니다.
- `explain("allPlansExecution")`: 후보였던 모든 계획을 다 실행해보고 비교 결과를 보여주는, 가장 상세하지만 가장 느린 모드입니다.

#### **6. 추가하고 싶은 내용**

MongoDB Compass와 같은 GUI 도구를 사용하면 `explain` 결과를 시각적인 다이어그램 형태로 보여주어 훨씬 직관적으로 쿼리 실행 계획을 분석할 수 있습니다.

---

### **Part 2: 인덱스와 정렬(Sort)**

인덱스가 `find` 뿐만 아니라 `sort` 작업의 성능에도 얼마나 결정적인 영향을 미치는지 알아봅니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// createdAt 필드에 내림차순(-1) 인덱스 생성
db.posts.createIndex({ createdAt: -1 });

// 인덱스와 동일한 순서로 정렬 (매우 효율적)
db.posts.find({}).sort({ createdAt: -1 }).explain("executionStats");
```

: 게시물을 최신순으로 정렬하는 쿼리입니다. `createdAt: -1` 인덱스가 `sort({ createdAt: -1 })`와 완벽하게 일치하므로, MongoDB는 별도의 정렬 과정 없이 인덱스를 순서대로 읽기만 하면 됩니다.

#### **2. 인덱스 생성 로직 및 DB의 데이터 접근 순서**

##### **정렬 시 인덱스가 없을 때**

1.  **[사용자]** `db.posts.find().sort({ createdAt: -1 })` 쿼리 실행.
2.  **[MongoDB]** `createdAt` 필드에 사용할 인덱스가 없음.
3.  **[MongoDB]** `posts` 컬렉션의 **모든 문서를 일단 메모리로** 불러옴.
4.  **[MongoDB]** 메모리 상에서 `createdAt` 필드 값을 기준으로 **정렬 알고리즘을 실행** (데이터가 많으면 매우 비싼 작업).
5.  **[MongoDB]** 정렬이 완료된 결과를 사용자에게 반환.
6.  **[결과]** `explain` 결과에 별도의 `SORT` 단계가 표시됩니다. 대용량 데이터에서는 메모리 부족 오류를 일으킬 수도 있습니다.

##### **정렬 시 인덱스가 있을 때**

1.  **[사용자]** `db.posts.find().sort({ createdAt: -1 })` 쿼리 실행.
2.  **[MongoDB]** 쿼리의 `sort` 조건과 **정확히 일치하는 `createdAt: -1` 인덱스**를 발견.
3.  **[MongoDB]** 인덱스는 이미 `createdAt` 기준으로 **미리 정렬되어 있는 상태**.
4.  **[MongoDB]** 별도의 정렬 작업 없이, 인덱스의 **처음부터 끝까지 순서대로** 읽어나가며 문서 주소를 가져오고, 해당 문서들을 차례로 사용자에게 반환.
5.  **[결과]** `explain` 결과에 별도의 `SORT` 단계가 나타나지 않습니다. 메모리를 거의 사용하지 않고 매우 빠르게 정렬 결과를 얻을 수 있습니다.

#### **3. 해당 설명**

인덱스는 데이터를 빠르게 '찾는' 기능뿐만 아니라, 데이터를 효율적으로 '정렬'하는 기능도 제공합니다. `sort()` 조건과 일치하는 인덱스가 있다면, MongoDB는 비용이 많이 드는 인메모리(in-memory) 정렬 과정을 생략하고 이미 정렬된 인덱스를 그대로 읽어오므로 성능이 비약적으로 향상됩니다.

#### **4. 응용 가능한 예제**

**"쇼핑몰에서 상품을 '낮은 가격순', '높은 가격순', '최신 등록순'으로 정렬하는 기능"**
각 정렬 옵션에 맞춰 `price: 1`, `price: -1`, `registeredAt: -1` 과 같은 단일-키 인덱스를 생성해두면, 사용자가 어떤 정렬 옵션을 선택하더라도 빠른 응답 속도를 제공할 수 있습니다.

#### **5. 심화 내용 (정렬 방향)**

`{ createdAt: 1 }` (오름차순) 인덱스는 `{ createdAt: -1 }` (내림차순) 정렬에도 사용될 수 있습니다. MongoDB가 인덱스를 그냥 거꾸로 읽으면 되기 때문입니다. 하지만 복합 인덱스에서는 각 필드의 정렬 방향이 모두 중요해집니다.

#### **6. 추가하고 싶은 내용**

MongoDB에는 32MB의 인메모리 정렬 제한이 있습니다. 인덱스 없이 대용량 데이터를 정렬하려고 하면 이 제한을 초과하여 쿼리가 실패할 수 있습니다. 따라서 대용량 컬렉션에서 정렬은 사실상 **인덱스가 필수**라고 생각하는 것이 좋습니다.

---

### **Part 3: 복합 인덱스의 필드 순서와 활용**

복합 인덱스를 생성할 때 왜 필드 순서가 그토록 중요한지, 다양한 쿼리 예시를 통해 알아봅니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 복합 인덱스 생성: author가 첫 번째, category가 두 번째 기준
db.posts.createIndex({ author: 1, category: 1 });
```

: `author`로 먼저 정렬하고, `author`가 같을 경우 그 안에서 `category`로 다시 정렬하는 방식의 인덱스를 생성합니다. (전화번호부에서 '성'으로 먼저 찾고, 동명이인일 경우 '이름'으로 찾는 것과 같음)

```javascript
// ✅ CASE 1: 인덱스 순서와 일치 (최적)
db.posts.find({ author: "User A", category: "Tech" });

// ✅ CASE 2: 인덱스의 첫 필드만 사용 (효율적)
db.posts.find({ author: "User A" });

// ❌ CASE 3: 인덱스의 두 번째 필드만 사용 (비효율적)
db.posts.find({ category: "Tech" });

// ✅ CASE 4: 첫 필드는 동등 비교, 두 번째 필드는 정렬에 사용 (최적)
db.posts.find({ author: "User A" }).sort({ category: 1 });
```

: 각 케이스별로 생성된 복합 인덱스가 얼마나 효율적으로 사용되는지를 보여줍니다.

#### **2. 인덱스 생성 로직 및 DB의 데이터 접근 순서**

##### **복합 인덱스 생성 (`{ author: 1, category: 1 }`)**

1.  **[MongoDB]** 모든 문서에서 `author`와 `category` 값, 그리고 문서 주소를 수집합니다.
2.  **[MongoDB]** 수집된 데이터를 **`author`를 기준으로 먼저** 알파벳순으로 정렬합니다.
3.  **[MongoDB]** `author` 값이 같은 그룹 내에서는 **`category`를 기준으로 다시** 알파벳순으로 정렬합니다.
4.  **[MongoDB]** 이 최종 정렬 결과를 B-Tree 구조로 저장합니다.

| `author` | `category` | → 문서 주소 |
| :------- | :--------- | :---------- |
| User A   | Life       | @Addr3      |
| User A   | **Tech**   | @Addr1      |
| User B   | Health     | @Addr2      |

##### **데이터 접근 순서 (CASE 별)**

- **CASE 1 (`author`, `category` 둘 다 조건):**

  1.  **[MongoDB]** 인덱스에서 `author`가 "User A"인 구간을 빠르게 찾습니다.
  2.  **[MongoDB]** 그 좁은 구간 내에서 `category`가 "Tech"인 항목을 다시 빠르게 찾습니다.
  3.  **[결과]** 가장 효율적인 **`IXSCAN`**.

- **CASE 2 (`author`만 조건):**

  1.  **[MongoDB]** 인덱스에서 `author`가 "User A"인 구간을 빠르게 찾습니다.
  2.  **[MongoDB]** 해당 구간의 모든 항목("Life", "Tech")이 조건에 맞으므로 모두 반환합니다.
  3.  **[결과]** 인덱스의 앞부분(prefix)만 사용. 여전히 효율적인 **`IXSCAN`**.

- **CASE 3 (`category`만 조건):**

  1.  **[MongoDB]** 인덱스는 `author` 기준으로 정렬되어 있어, `category`가 "Tech"인 데이터가 어디 있는지 바로 알 수 없습니다 ("Tech"는 "User A" 밑에도, "User C" 밑에도 있을 수 있음).
  2.  **[MongoDB]** 인덱스를 활용하더라도, **인덱스 전체를 스캔**해야만 모든 "Tech" 카테고리를 찾을 수 있습니다.
  3.  **[결과]** `COLLSCAN`보다는 낫지만, CASE 1, 2에 비해 비효율적인 **`IXSCAN`**이 됩니다.

- **CASE 4 (`author` 조건, `category` 정렬):**
  1.  **[MongoDB]** 인덱스에서 `author`가 "User A"인 구간을 빠르게 찾습니다.
  2.  **[MongoDB]** 이 구간은 이미 `category` 순서로 정렬되어 있습니다.
  3.  **[MongoDB]** 별도의 정렬 작업 없이, 해당 구간을 순서대로 읽어 결과를 반환합니다.
  4.  **[결과]** 찾기와 정렬 모두에서 인덱스를 완벽하게 활용하는 **최적의 `IXSCAN`**.

#### **3. 해당 설명**

복합 인덱스에서는 **필드의 순서가 절대적**입니다. 쿼리가 인덱스를 효율적으로 사용하려면, 인덱스에 정의된 필드 순서의 앞부분(prefix)부터 순서대로 조건에 포함되어야 합니다. 인덱스 중간의 필드를 건너뛰고 뒤쪽 필드만 조건으로 사용하면 인덱스의 효율이 크게 떨어집니다.

#### **4. 응용 가능한 예제**

**"국가(country)별, 도시(city)별 사용자 수를 집계하는 대시보드"**
사용자가 항상 '국가'를 먼저 선택하고 그 다음 '도시'를 선택한다면, 인덱스는 `{ country: 1, city: 1 }` 순서로 생성해야 합니다. 만약 `{ city: 1, country: 1 }`로 만들면, 특정 국가의 모든 도시를 찾는 쿼리에서 인덱스를 제대로 활용할 수 없게 됩니다.

#### **5. 심화 내용 (ESR - Equality, Sort, Range 규칙)**

복합 인덱스 필드 순서를 정하는 효과적인 규칙입니다.

1.  **Equality (동등 비교)**: `=` 또는 `$in` 처럼 정확한 값을 찾는 조건을 가장 앞에 둡니다.
2.  **Sort (정렬)**: `sort()`에 사용되는 필드를 그 다음에 둡니다.
3.  **Range (범위)**: `$gt`, `$lt` 처럼 범위를 검색하는 조건을 가장 마지막에 둡니다.
    이 순서대로 인덱스를 구성하면 대부분의 쿼리에서 최고의 성능을 낼 수 있습니다.

#### **6. 추가하고 싶은 내용**

어떤 필드를 먼저 둘지 고민될 때는 **'카디널리티(Cardinality)'**가 높은 필드를 앞에 두는 것이 일반적인 가이드라인 중 하나입니다. 카디널리티란 필드가 가진 고유한 값의 개수를 의미합니다. 주민등록번호처럼 거의 모든 값이 다른 필드는 카디널리티가 높고, '성별'처럼 값이 몇 개 없는 필드는 카디널리티가 낮습니다.

---

### **Part 4: 고급 인덱스 활용 (`$or`, Covered Query, `hint`)**

인덱스를 더 똑똑하게 사용하거나, 때로는 MongoDB의 결정을 무시하고 직접 제어하는 방법을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 1. $or 쿼리와 인덱스
// (사전 조건: author와 category에 각각 단일 인덱스가 있다고 가정)
db.posts.find({ $or: [{ author: "User A" }, { category: "Health" }] });
```

: `author`가 "User A"이거나 **또는(OR)** `category`가 "Health"인 게시물을 찾습니다. MongoDB는 각 조건에 해당하는 인덱스를 각각 사용한 뒤, 결과를 합칠 수 있습니다.

```javascript
// 2. 커버드 쿼리 (Covered Query)
db.posts.find(
  { author: "User A", category: "Tech" },
  { _id: 0, author: 1, category: 1 }
);
```

: `{ author: 1, category: 1 }` 인덱스가 있을 때, 쿼리에 필요한 모든 정보(조건 필드, 반환 필드)가 인덱스 안에 다 들어있어, 실제 문서를 보러 가지 않고 인덱스만 읽고 결과를 반환하는 초고속 쿼리입니다.

````javascript
// 3. 인덱스 강제 지정 (hint)
db.posts.find({ author: "User A" }).hint({ author: 1 });```
````

: MongoDB 쿼리 플래너의 선택을 무시하고, 무조건 `{ author: 1 }` 인덱스를 사용하도록 강제로 지시합니다.

#### **2. 해당 설명**

- **`$or`와 인덱스**: `$or` 연산자는 각 절(`[]`안의 `{}`)이 독립적으로 인덱스를 사용할 수 있습니다. 만약 `{ author: 1 }` 인덱스와 `{ category: 1 }` 인덱스가 모두 있다면, MongoDB는 두 인덱스를 모두 사용하여 각각의 결과를 찾은 후, 중복을 제거하고 최종 결과를 반환합니다.
- **커버드 쿼리**: 인덱스 활용의 꽃입니다. 디스크 I/O 없이 메모리 위의 인덱스만으로 쿼리를 완전히 처리하므로 가장 빠른 응답 속도를 보장합니다. 조건은 ① 쿼리의 모든 조건 필드가 인덱스에 포함, ② 쿼리의 모든 반환 필드(프로젝션)가 인덱스에 포함, ③ `_id`는 반환에서 제외되어야 합니다.
- **`hint`**: 쿼리 플래너가 가끔 최적이 아닌 인덱스를 선택하는 특수한 경우, 또는 성능 테스트를 위해 특정 인덱스의 성능을 측정하고 싶을 때 사용하는 전문가용 도구입니다. 일반적으로는 쿼리 플래너가 대부분 올바른 결정을 하므로 자주 사용할 필요는 없습니다.

---

#### **3. 응용 가능한 예제**

**"모바일 앱의 푸시 알림을 위해, '마케팅 수신에 동의'했거나 또는 'VIP 등급'인 모든 사용자의 토큰을 조회하는 경우"**
이때 `$or`를 사용하며, `marketingAgree: true`와 `grade: "VIP"`에 각각 인덱스가 있다면 빠른 조회가 가능합니다.

```javascript
db.users.find(
  { $or: [{ marketingAgree: true }, { grade: "VIP" }] },
  { _id: 0, pushToken: 1 } // 푸시 토큰만 필요
);
```

#### **4. 심화 내용 (커버드 쿼리가 안 되는 경우)**

인덱스에 포함되지 않은 필드를 프로젝션에 추가하는 순간 커버드 쿼리는 깨집니다. 예를 들어, 위 커버드 쿼리 예제에서 `title`을 추가로 요청(`{_id:0, author:1, category:1, title:1}`)하면, `title` 정보는 인덱스에 없기 때문에 MongoDB는 어쩔 수 없이 디스크의 실제 문서를 찾아가야 합니다. `explain` 결과의 `stage`를 보면 `IXSCAN` 아래에 `FETCH` 단계가 추가된 것을 볼 수 있습니다.

#### **5. 추가하고 싶은 내용**

`hint`는 강력하지만 위험할 수 있는 도구입니다. `hint`로 지정한 인덱스가 삭제되거나 변경되면 해당 쿼리는 오류를 발생시킵니다. 또한 데이터 분포가 바뀌면 쿼리 플래너의 선택이 더 현명해질 수 있는데, `hint`는 이런 유연성을 막아버립니다. 따라서 꼭 필요한 경우가 아니면 쿼리 플래너를 신뢰하는 것이 좋습니다.
