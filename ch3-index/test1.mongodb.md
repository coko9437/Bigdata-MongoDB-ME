---
### **ch3 코드 종합 설명**

이 코드는 MongoDB의 **쿼리 성능을 극대화**하기 위한 핵심 기술인 **인덱스(Index)**에 대해 설명합니다. 인덱스가 왜 필요한지(이론적 배경), 어떻게 만들고 관리하는지(기본 문법), 그리고 어떤 상황에 어떤 종류의 인덱스를 사용해야 하는지(다양한 인덱스 타입)를 예제와 함께 상세히 배울 수 있습니다.
---

### **Part 1: 인덱스(Index)의 기본 개념과 원리**

인덱스가 무엇이며, 왜 사용해야 하는지에 대한 근본적인 원리를 이해합니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 1. 인덱스 없이 검색 (Full Collection Scan)
db.users.find({ age: 30 });
```

: 인덱스가 없는 상태에서는 `age`가 30인 사용자를 찾기 위해 `users` 컬렉션의 모든 문서를 처음부터 끝까지 하나씩 확인해야 합니다.

```javascript
// 2. 인덱스 생성 후 검색 (Index Scan)
db.users.createIndex({ age: 1 });
db.users.find({ age: 30 });
```

: `age` 필드에 인덱스를 생성하면, MongoDB는 정렬된 인덱스 구조(B-Tree)를 사용하여 훨씬 빠르게 `age`가 30인 사용자를 찾아냅니다.

#### **2. 해당 설명**

인덱스는 데이터베이스의 '책 찾아보기(색인)'와 같습니다. 책 전체(컬렉션)를 한 페이지씩 넘겨보며 원하는 내용을 찾는 대신, 책 뒤편의 색인(인덱스)에서 원하는 단어가 몇 페이지에 있는지 바로 찾아가는 원리입니다.

- **O(n) - 선형 시간**: 인덱스가 없으면 데이터(n)가 많아질수록 찾는 시간도 정비례해서 늘어납니다. 이를 **Full Collection Scan**이라고 하며, 데이터가 많을 때 성능 저하의 주된 원인이 됩니다.
- **O(log n) - 로그 시간**: 인덱스를 사용하면 데이터(n)가 아무리 많아져도 찾는 시간은 매우 완만하게 증가합니다. 이는 정렬된 트리 구조에서 원하는 값을 효율적으로 찾아가는 **이진 탐색(Binary Search)** 덕분입니다.

#### **3. 응용 가능한 예제**

**"수백만 명의 회원이 있는 웹사이트에서 사용자가 자신의 이메일 주소로 로그인을 시도하는 상황"**

- **인덱스 없을 때**: 로그인 요청이 올 때마다 수백만 개의 사용자 문서 전체를 뒤져서 일치하는 이메일을 찾아야 하므로 로그인이 매우 느려집니다.
- **인덱스 있을 때**: `email` 필드에 인덱스를 생성해두면, 시스템은 즉시 해당 이메일을 가진 사용자를 찾아내어 빠른 로그인을 제공할 수 있습니다.

#### **4. 심화 내용 (쿼리 플래너와 `explain()`)**

MongoDB는 쿼리를 실행하기 전에 '쿼리 플래너'를 통해 어떤 방식으로 데이터를 찾는 것이 가장 효율적일지 결정합니다. 내 쿼리가 인덱스를 잘 사용하고 있는지 확인하려면 `.explain()` 명령어를 사용하면 됩니다.

```javascript
// 이 쿼리가 어떻게 실행되는지 계획을 확인합니다.
db.users.find({ age: 30 }).explain("executionStats");
```

결과에서 `winningPlan` 부분을 확인했을 때, `stage`가 `COLLSCAN`이면 풀 스캔을 의미하고, `IXSCAN`이면 인덱스를 성공적으로 사용했다는 의미입니다.

#### **5. 추가하고 싶은 내용**

인덱스는 검색 속도를 비약적으로 향상시키지만, 공짜는 아닙니다.

- **저장 공간**: 인덱스는 추가적인 저장 공간을 차지합니다.
- **쓰기 속도 저하**: 데이터를 삽입(Insert), 수정(Update), 삭제(Delete)할 때마다 인덱스도 함께 업데이트되어야 하므로, 쓰기 작업이 약간 느려질 수 있습니다.
  따라서 모든 필드에 인덱스를 만드는 것이 아니라, **자주 조회되는 필드**에만 전략적으로 생성하는 것이 중요합니다.

---

### **Part 2: 인덱스의 기본 관리 (생성, 조회, 삭제)**

인덱스를 직접 만들고, 확인하고, 삭제하는 기본적인 명령어들을 익힙니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// age 필드에 오름차순(1)으로 인덱스 생성
db.users.createIndex({ age: 1 });
```

: `users` 컬렉션의 `age` 필드를 기준으로 오름차순(숫자가 작은 것부터)으로 정렬된 인덱스를 생성합니다. 내림차순은 `-1`을 사용합니다.

````javascript
// 현재 컬렉션의 모든 인덱스 목록 조회
db.users.getIndexes();```
: `users` 컬렉션에 생성된 모든 인덱스의 목록과 정보를 확인합니다. `_id` 필드의 기본 인덱스도 함께 표시됩니다.

```javascript
// 특정 인덱스 삭제
db.users.dropIndex("age_1");
````

: `getIndexes()`로 확인한 인덱스 이름("age_1")을 사용하여 `age` 필드에 생성했던 인덱스를 삭제합니다.

#### **2. 해당 설명**

`createIndex`, `getIndexes`, `dropIndex`는 인덱스를 관리하는 가장 기본적인 3가지 명령어입니다. 인덱스를 생성할 때는 필드 이름과 정렬 방향(`1` 또는 `-1`)을 지정하며, 삭제할 때는 `getIndexes`를 통해 얻은 인덱스의 고유한 이름을 사용합니다. MongoDB는 컬렉션을 만들 때 자동으로 모든 문서의 고유 식별자인 `_id` 필드에 인덱스를 생성해 줍니다.

#### **3. 응용 가능한 예제**

**"사용자 가입 날짜(`joinedAt`)를 기준으로 최신 가입자를 찾는 경우가 많아 인덱스를 생성했다가, 나중에 정책이 바뀌어 더 이상 필요 없어져 삭제하는 시나리오"**

```javascript
// 1. 최신 가입자 순으로 정렬하기 위해 'joinedAt' 필드에 내림차순 인덱스 생성
db.users.createIndex({ joinedAt: -1 });

// 2. 인덱스가 잘 생성되었는지 목록 확인
db.users.getIndexes();

// 3. 더 이상 사용하지 않게 되어 인덱스 삭제 (인덱스 이름이 'joinedAt_-1' 이라고 가정)
db.users.dropIndex("joinedAt_-1");
```

#### **4. 심화 내용 (`dropIndexes`)**

하나가 아닌, `_id`를 제외한 모든 인덱스를 한 번에 삭제하고 싶을 때는 `dropIndexes()` 명령어를 사용할 수 있습니다.

```javascript
// _id 인덱스를 제외한 모든 인덱스를 삭제합니다. (주의해서 사용해야 합니다!)
db.users.dropIndexes();
```

**주의**: 운영 중인 서비스 환경에서 이 명령어를 잘못 사용하면 모든 쿼리 성능이 급격히 저하될 수 있으므로 매우 신중하게 사용해야 합니다.

#### **5. 추가하고 싶은 내용**

인덱스 이름은 보통 MongoDB가 `필드명_방향` (예: `age_1`) 형식으로 자동 생성해 줍니다. 하지만 `createIndex` 명령어에 `{ name: "my_custom_index_name" }` 옵션을 추가하여 직접 원하는 이름으로 지정할 수도 있습니다.

---

### **Part 3: 단일-키 인덱스와 복합 인덱스**

하나의 필드로 인덱스를 만들지, 여러 필드를 묶어서 만들지에 대한 전략을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

````javascript
// 1. 단일-키 인덱스 (Single-key Index)
db.users.createIndex({ name: 1 });```
: `name`이라는 **단 하나의 필드**에 대해서만 인덱스를 생성합니다. `name`으로 사용자를 검색할 때 속도가 빨라집니다.

```javascript
// 2. 복합 인덱스 (Compound Index)
db.users.createIndex({ age: 1, city: 1 });
````

: `age`와 `city`라는 **두 개 이상의 필드**를 조합하여 하나의 인덱스를 생성합니다. `age`와 `city`를 **동시에** 조건으로 검색할 때 최고의 성능을 발휘합니다.

#### **2. 해당 설명**

- **단일-키 인덱스**: 특정 필드 하나를 기준으로 하는 검색이 빈번할 때 사용합니다. 예를 들어, `사용자 아이디`나 `이메일`로 검색하는 경우입니다.
- **복합 인덱스**: 여러 필드를 `AND` 조건으로 묶어 검색하는 경우가 많을 때 사용합니다. 예를 들어, '30대(`age`)이면서 서울(`city`)에 사는 사용자'를 찾는 경우입니다. 복합 인덱스에서 **필드 순서**는 매우 중요합니다. `{ age: 1, city: 1 }` 인덱스는 `age`만으로 검색할 때도 활용될 수 있지만, `city`만으로 검색할 때는 전혀 도움이 되지 않습니다. (전화번호부에서 '김씨'를 찾는 것은 쉽지만, 이름이 '민준'인 사람을 찾는 것은 어려운 것과 같습니다.)

#### **3. 응용 가능한 예제**

**"온라인 쇼핑몰에서 '여성 의류' 카테고리 상품을 '낮은 가격' 순으로 정렬해서 보여주는 페이지"**
이 페이지는 `category` 필드로 필터링하고 `price` 필드로 정렬하는 작업이 항상 함께 일어납니다. 따라서 복합 인덱스가 매우 효과적입니다.

```javascript
// 카테고리(오름차순)와 가격(오름차순)으로 복합 인덱스 생성
db.products.createIndex({ category: 1, price: 1 });

// 위 인덱스를 효율적으로 사용하는 쿼리
db.products.find({ category: "여성 의류" }).sort({ price: 1 });
```

#### **4. 심화 내용 (인덱스 프리픽스 - Index Prefix)**

복합 인덱스 `{ a: 1, b: 1, c: 1 }`은 인덱스의 앞부분(prefix)에 해당하는 필드 조합의 쿼리도 지원합니다.

- `{ a: ... }` (O)
- `{ a: ..., b: ... }` (O)
- `{ a: ..., b: ..., c: ... }` (O)
- 하지만 `{ b: ... }` 나 `{ c: ... }` 혹은 `{ a: ..., c: ... }` 같은 쿼리에는 이 인덱스가 효율적으로 사용되지 못합니다. 쿼리 패턴을 분석하여 필드 순서를 신중하게 결정해야 하는 이유입니다.

#### **5. 추가하고 싶은 내용**

`age`에 단일 인덱스, `city`에 단일 인덱스를 각각 만드는 것보다, `age`와 `city`를 함께 검색하는 경우가 많다면 `{ age: 1, city: 1 }` 복합 인덱스 하나를 만드는 것이 대부분의 경우 더 효율적입니다. MongoDB는 하나의 쿼리에 대해 특별한 경우를 제외하고는 단 하나의 인덱스만 사용하기 때문입니다.

---

### **Part 4: 인덱스의 주요 옵션들 (Unique, Sparse, Partial)**

기본 인덱스에 특별한 규칙이나 조건을 부여하여 더 똑똑하게 만드는 방법을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 1. 고유 인덱스 (Unique Index)
db.users.createIndex({ email: 1 }, { unique: true });
```

: `email` 필드에 인덱스를 생성하되, 이 필드의 값은 컬렉션 내에서 절대 중복될 수 없다는 규칙을 추가합니다. 회원가입 시 이메일 중복 방지에 사용됩니다.

```javascript
// 2. 희소 인덱스 (Sparse Index)
db.customers.createIndex({ location: 1 }, { sparse: true });
```

: `location` 필드가 **존재하는 문서에 대해서만** 인덱스에 포함시킵니다. `location` 필드가 없는 문서는 인덱스에서 아예 제외되어 공간을 절약합니다.

```javascript
// 3. 부분 인덱스 (Partial Index)
db.users.createIndex(
  { age: 1 },
  { partialFilterExpression: { age: { $gte: 30 } } }
);
```

: `age`가 30 이상인 문서처럼, **특정 조건을 만족하는 문서에 대해서만** 인덱스를 생성합니다. `sparse` 인덱스보다 더 구체적인 조건을 줄 수 있습니다.

#### **2. 해당 설명**

- **Unique Index**: 데이터의 무결성을 보장하는 데 사용됩니다. `_id` 외에도 중복을 허용하지 않아야 하는 필드(예: 사용자 ID, 이메일, 주민등록번호)에 적용하여 데이터베이스 수준에서 중복 입력을 막아줍니다.
- **Sparse Index**: 어떤 필드가 일부 문서에는 있고, 일부 문서에는 없는 경우 유용합니다. 예를 들어, 추천인(`recommender`) 필드는 추천인이 있는 사용자 문서에만 존재할 것입니다. 이 필드에 `sparse` 인덱스를 걸면 추천인이 없는 수많은 사용자는 인덱스에 포함되지 않아 효율적입니다.
- **Partial Index**: `sparse` 인덱스와 비슷하지만, 필드의 존재 여부뿐만 아니라 값에 대한 구체적인 조건(`age > 30`, `status: "active"`)으로 인덱스 대상을 한정할 수 있습니다. '현재 활동 중인 VIP 회원'처럼 매우 자주 조회되는 특정 데이터 집합에 대한 인덱스를 만들 때 사용하면 인덱스 크기를 크게 줄이고 성능을 높일 수 있습니다.

#### **3. 응용 가능한 예제**

**"배송이 완료되지 않은(`status: "shipping"`) 주문 건만 빠르게 조회해야 하는 물류 관리 시스템"**
전체 주문 중 배송 중인 주문은 일부일 것입니다. 따라서 `partial` 인덱스를 사용하면 매우 효율적입니다.

```javascript
// 'status'가 "shipping"인 주문에 대해서만 인덱스 생성
db.orders.createIndex(
  { createdAt: 1 }, // 주문 생성일 기준 정렬
  { partialFilterExpression: { status: "shipping" } }
);

// 위 인덱스를 효율적으로 사용하는 쿼리
db.orders.find({ status: "shipping" }).sort({ createdAt: 1 });
```

#### **4. 심화 내용 (Unique + Sparse 조합)**

필드가 없는 경우(null)는 중복으로 간주되지 않게 하면서, 필드가 존재할 때는 반드시 고유한 값을 갖도록 만들고 싶을 때 `unique`와 `sparse` 옵션을 함께 사용할 수 있습니다. 예를 들어, 선택적으로 입력하는 '개인 웹사이트 주소'는 입력하지 않은 사람은 여러 명일 수 있지만, 입력한 주소는 서로 달라야 하는 경우에 유용합니다.

#### **5. 추가하고 싶은 내용**

어떤 옵션을 선택할지는 데이터의 분포와 쿼리 패턴에 따라 달라집니다.

- 필드 값이 **절대 중복되면 안 되면** → `Unique`
- 필드가 **있거나 없는 경우가 많고, 있을 때만** 검색하면 → `Sparse`
- **특정 조건을 만족하는 일부 문서만** 집중적으로 검색하면 → `Partial`

---

### **Part 5: 고급 및 운영 인덱스 (Background, Covered)**

서비스 운영 중에 인덱스를 다루거나, 쿼리 성능을 극한으로 끌어올리는 기술을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

```javascript
// 1. 백그라운드 인덱스 (Background Index)
db.users.createIndex({ age: 1 }, { background: true });
```

: **(구버전)** 사용자가 많은 서비스가 운영 중인 상태에서 인덱스를 생성할 때, 다른 DB 작업을 막지 않고 백그라운드에서 천천히 인덱스를 생성합니다.

```javascript
// 2. 커버드 쿼리 (Covered Query)
db.products.createIndex({ name: 1, price: 1 });
db.products.find({ name: "Laptop" }, { _id: 0, name: 1, price: 1 });
```

: 쿼리에 필요한 **모든 정보(조회 조건, 반환 필드)가 인덱스 안에 다 포함**되어 있어, 실제 데이터 문서를 읽으러 디스크에 접근할 필요 없이 인덱스만으로 결과를 반환하는 쿼리입니다.

#### **2. 해당 설명**

- **Background Index**: **(중요)** MongoDB 4.2 버전부터는 모든 인덱스 생성이 기본적으로 백그라운드 작업과 유사하게 동작하도록 개선되어, `background: true` 옵션은 더 이상 큰 의미가 없습니다. 하지만 구버전 시스템을 다루거나 개념을 이해하는 차원에서 알아두면 좋습니다. 대용량 데이터에 인덱스를 생성하는 동안 서비스 전체가 멈추는 것을 방지하기 위한 옵션이었습니다.
- **Covered Query**: 최고의 성능을 내는 쿼리 방식입니다. 데이터베이스는 디스크에서 문서를 가져오는 작업(I/O)이 가장 느린 작업 중 하나입니다. 커버드 쿼리는 이 작업을 생략하고 메모리 위의 인덱스 정보만으로 응답하므로 속도가 매우 빠릅니다. 이를 위해서는 ①쿼리 조건에 사용된 필드가 인덱스에 포함되고, ②결과로 요청하는 필드(프로젝션)도 모두 인덱스에 포함되어야 하며, ③`_id` 필드는 결과에서 제외(`_id: 0`)되어야 합니다. (단, `_id`가 인덱스에 포함된 경우는 예외)

#### **3. 응용 가능한 예제**

**"블로그 게시글 목록 페이지에서 각 게시글의 제목과 작성자만 빠르게 보여주는 경우"**
본문 내용은 무거우니 목록에서는 보여주지 않습니다. 이럴 때 커버드 쿼리를 활용할 수 있습니다.

```javascript
// 게시글 목록을 위한 커버드 인덱스 생성
db.posts.createIndex({ category: 1, createdAt: -1, title: 1, author: 1 });

// 'news' 카테고리의 최신글 10개의 제목과 작성자만 조회 (커버드 쿼리)
db.posts
  .find({ category: "news" }, { _id: 0, title: 1, author: 1 })
  .sort({ createdAt: -1 })
  .limit(10);
```

이 쿼리는 `title`과 `author` 필드가 인덱스에 포함되어 있으므로, 무거운 `content` 필드가 있는 실제 문서를 읽지 않고 매우 빠르게 결과를 반환합니다.

#### **4. 심화 내용 (인덱스 교차 - Index Intersection)**

최신 MongoDB 버전에서는 쿼리 플래너가 때로는 여러 개의 단일-키 인덱스를 함께 활용하여 결과를 찾아내기도 합니다. 이를 '인덱스 교차'라고 합니다. 예를 들어 `{ age: 1 }` 인덱스와 `{ city: 1 }` 인덱스가 모두 있을 때, `find({ age: 30, city: "Seoul" })` 쿼리는 각 인덱스에서 결과를 뽑아 교집합을 찾는 방식으로 동작할 수 있습니다. 하지만 대부분의 경우, 잘 설계된 복합 인덱스 하나가 더 나은 성능을 보입니다.

#### **5. 추가하고 싶은 내용**

인덱스 생성은 데이터가 많을수록 오래 걸리는 작업입니다. 운영 중인 서비스에 새로운 인덱스를 추가할 때는 데이터베이스 부하가 적은 시간대를 이용하고, `db.currentOp()` 같은 명령어로 진행 상황을 모니터링하는 것이 좋습니다.

---

### **Part 6: 특수 목적 인덱스: 지리 공간(GeoSpatial) 인덱스**

위도, 경도와 같은 위치 데이터를 빠르고 효율적으로 검색하는 방법을 배웁니다.

#### **1. 코드, 문법 및 개별 설명**

````javascript
// 1. 2dsphere 인덱스 생성
db.locations.createIndex({ coordinates: "2dsphere" });```
: `coordinates` 필드에 저장된 위치 좌표(경도, 위도)를 지구와 같은 구체(Sphere) 표면 기준으로 검색할 수 있도록 `2dsphere` 인덱스를 생성합니다.

```javascript
// 2. 특정 지점 근처 검색 ($nearSphere)
db.locations.find({
  coordinates: {
    $nearSphere: {
      $geometry: { type: "Point", coordinates: [126.9784, 37.5665] },
      $maxDistance: 10000  // 단위: 미터 (10km)
    }
  }
});
````

: 특정 지점(`[126.9784, 37.5665]`)으로부터 최대 10km 반경 내에 있는 장소들을 **가까운 순서대로 정렬하여** 찾아냅니다.

```javascript
// 3. 특정 영역 내 검색 ($geoWithin)
db.locations.find({
  coordinates: { $geoWithin: { $center: [[126.9784, 37.5665], 1] } },
});
```

: 특정 지점을 중심으로 하는 원형, 사각형(`$box`), 다각형(`$polygon`) 영역 **안에 포함되는** 모든 장소를 찾습니다. (거리순 정렬은 안 됨)

#### **2. 해당 설명**

지리 공간 인덱스는 '내 주변 맛집 찾기', '가장 가까운 택시 호출하기'와 같은 위치 기반 서비스(LBS)의 핵심 기술입니다.

- **데이터 형식**: 인덱스를 사용하려면 위치 데이터가 GeoJSON 형식(예: `{ type: "Point", coordinates: [경도, 위도] }`)으로 저장되어 있어야 합니다. **경도(longitude)가 위도(latitude)보다 먼저 오는 순서**에 반드시 주의해야 합니다.
- **`2dsphere` 인덱스**: 지구의 곡률을 계산하여 실제 구체 표면에서의 거리를 정확하게 측정합니다. 전 세계적인 서비스를 다룰 때 필수적입니다.
- **주요 쿼리 연산자**:
  - `$nearSphere`: 특정 지점에서 **가까운 순서**로 결과를 찾아야 할 때 사용합니다. (예: 가장 가까운 카페 5곳)
  - `$geoWithin`: 특정 **영역 안에 들어오는** 모든 결과를 찾을 때 사용합니다. (예: 강남구 안에 있는 모든 편의점)

#### **3. 응용 가능한 예제**

**"배달 앱에서 사용자의 현재 위치(경도 127.02, 위도 37.49)에서 3km 이내에 있고, '치킨' 카테고리에 속하는 가게들을 검색하기"**
이 경우, 위치 검색과 일반 필드 검색을 함께 사용합니다.

```javascript
// 가게 위치와 카테고리에 복합 인덱스 생성
db.stores.createIndex({ location: "2dsphere", category: 1 });

// 쿼리 실행
db.stores.find({
  location: {
    $nearSphere: {
      $geometry: { type: "Point", coordinates: [127.02, 37.49] },
      $maxDistance: 3000, // 3km
    },
  },
  category: "치킨",
});
```

#### **4. 심화 내용 (`2d` 인덱스)**

`2dsphere` 인덱스 외에 `2d` 인덱스도 있습니다. `2d` 인덱스는 지구의 곡률을 고려하지 않고 평면(2D) 좌표계에서 거리를 계산합니다. 게임 맵처럼 좁은 영역이나 가상의 평면 공간에서 좌표를 다룰 때는 `2d` 인덱스가 더 빠르고 적합할 수 있습니다. 하지만 실제 지도 기반 서비스에서는 오차가 발생할 수 있어 `2dsphere` 사용이 강력히 권장됩니다.

#### **5. 추가하고 싶은 내용**

실무에서는 단순히 위치만 검색하는 경우보다, 위 응용 예제처럼 '3km 이내의 **평점 4.0 이상**인 카페'와 같이 다른 조건과 함께 사용하는 경우가 대부분입니다. 이럴 때는 위치 필드와 다른 필드를 묶어 **복합 인덱스**로 만드는 것이 성능에 매우 유리합니다.
